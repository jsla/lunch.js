{"version":3,"file":"element_ref.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/linker/element_ref.ts"],"names":[],"mappings":"AACA;IAEA;;OAEG;IACH,oBAAY,aAAkB;QAAI,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IAAC,CAAC;IACvE,iBAAC;AAAD,CAAC,AAND,IAMC;AAED;IACA;;;;;;;;;;;;;;;;;;;;OAoBG;IACH,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC;AACnC,CAAC","sourcesContent":["\nexport class ElementRef {\npublic nativeElement: any;\n/**\n * @param {?} nativeElement\n */\nconstructor(nativeElement: any) { this.nativeElement = nativeElement; }\n}\n\nfunction ElementRef_tsickle_Closure_declarations() {\n/**\n * The underlying native element or `null` if direct access to native elements is not supported\n * (e.g. when the application runs in a web worker).\n * \n * <div class=\"callout is-critical\">\n *   <header>Use with caution</header>\n *   <p>\n *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n *    data-binding provided by Angular instead. Alternatively you take a look at {\\@link Renderer}\n *    which provides API that can safely be used even when direct access to native elements is not\n *    supported.\n *   </p>\n *   <p>\n *    Relying on direct DOM access creates tight coupling between your application and rendering\n *    layers which will make it impossible to separate the two and deploy your application into a\n *    web worker.\n *   </p>\n * </div>\n * \\@stable\n * @type {?}\n */\nElementRef.prototype.nativeElement;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}