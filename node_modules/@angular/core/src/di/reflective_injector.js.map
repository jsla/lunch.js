{"version":3,"file":"reflective_injector.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/di/reflective_injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, THROW_IF_NOT_FOUND} from './injector';\nimport {Self, SkipSelf} from './metadata';\nimport {Provider} from './provider';\nimport {AbstractProviderError, CyclicDependencyError, InstantiationError, NoProviderError, OutOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst /** @type {?} */ UNDEFINED = new Object();\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n * \n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n * \n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n * \n * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n * \n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n * \n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n * \n * \\@stable\n * @abstract\n */\nexport abstract class ReflectiveInjector implements Injector {\n/**\n * Turns an array of provider definitions into an array of resolved providers.\n * \n * A resolution is a process of flattening multiple nested arrays and converting individual\n * providers into an array of {\\@link ResolvedReflectiveProvider}s.\n * \n * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n * \n * expect(providers.length).toEqual(2);\n * \n * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n * expect(providers[0].key.displayName).toBe(\"Car\");\n * expect(providers[0].dependencies.length).toEqual(1);\n * expect(providers[0].factory).toBeDefined();\n * \n * expect(providers[1].key.displayName).toBe(\"Engine\");\n * });\n * ```\n * \n * See {\\@link ReflectiveInjector#fromResolvedProviders} for more info.\n * @param {?} providers\n * @return {?}\n */\nstatic resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n/**\n * Resolves an array of providers and creates an injector from those providers.\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \n * This function is slower than the corresponding `fromResolvedProviders`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#fromResolvedProviders}.\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic resolveAndCreate(providers: Provider[], parent: Injector = null): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n/**\n * Creates an injector from previously resolved providers.\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, Engine]);\n * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \\@experimental\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent: Injector = null):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n/**\n * Parent of this injector.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n * \n * ```typescript\n * var parent = ReflectiveInjector.resolveAndCreate([]);\n * var child = parent.resolveAndCreateChild([]);\n * expect(child.parent).toBe(parent);\n * ```\n * @abstract\n * @return {?}\n */\nparent() {}\n/**\n * Resolves an array of providers and creates a child injector from those providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n * var child = parent.resolveAndCreateChild([ChildProvider]);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * \n * This function is slower than the corresponding `createChildFromResolved`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#createChildFromResolved}.\n * @abstract\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]) {}\n/**\n * Creates a child injector from previously resolved providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n * \n * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n * var child = parent.createChildFromResolved(childProviders);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * @abstract\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]) {}\n/**\n * Resolves a provider and instantiates an object in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * \n * var car = injector.resolveAndInstantiate(Car);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider) {}\n/**\n * Instantiates an object using a resolved provider in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * var carProvider = ReflectiveInjector.resolve([Car])[0];\n * var car = injector.instantiateResolved(carProvider);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider) {}\n/**\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any) {}\n}\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  /** @internal */\n  _constructionCounter: number = 0;\npublic _providers: ResolvedReflectiveProvider[];\npublic _parent: Injector;\n\n  keyIds: number[];\n  objs: any[];\n/**\n * Private\n * @param {?} _providers\n * @param {?=} _parent\n */\nconstructor(_providers: ResolvedReflectiveProvider[], _parent: Injector = null) {\n    this._providers = _providers;\n    this._parent = _parent;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n/**\n * @return {?}\n */\nget parent(): Injector { return this._parent; }\n/**\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n/**\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const /** @type {?} */ inj = new ReflectiveInjector_(providers);\n    inj._parent = this;\n    return inj;\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\ngetProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw new OutOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n/**\n * \\@internal\n * @param {?} provider\n * @return {?}\n */\n_new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw new CyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n/**\n * @return {?}\n */\nprivate _getMaxNumberOfObjects(): number { return this.objs.length; }\n/**\n * @param {?} provider\n * @return {?}\n */\nprivate _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const /** @type {?} */ res = new Array(provider.resolvedFactories.length);\n      for (let /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n/**\n * @param {?} provider\n * @param {?} ResolvedReflectiveFactory\n * @return {?}\n */\nprivate _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const /** @type {?} */ factory = ResolvedReflectiveFactory.factory;\n\n    let /** @type {?} */ deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch ( /** @type {?} */e) {\n      if (e instanceof AbstractProviderError || e instanceof InstantiationError) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let /** @type {?} */ obj: any;\n    try {\n      obj = factory(...deps);\n    } catch ( /** @type {?} */e) {\n      throw new InstantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n/**\n * @param {?} dep\n * @return {?}\n */\nprivate _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n/**\n * @param {?} key\n * @param {?} visibility\n * @param {?} notFoundValue\n * @return {?}\n */\nprivate _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf, notFoundValue: any): any {\n    if (key === INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n/**\n * @param {?} keyId\n * @return {?}\n */\nprivate _getObjByKeyId(keyId: number): any {\n    for (let /** @type {?} */ i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw new NoProviderError(this, key);\n    }\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const /** @type {?} */ obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @param {?} visibility\n * @return {?}\n */\n_getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf): any {\n    let /** @type {?} */ inj: Injector;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this._parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const /** @type {?} */ inj_ = /** @type {?} */(( <ReflectiveInjector_>inj));\n      const /** @type {?} */ obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_._parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n/**\n * @return {?}\n */\nget displayName(): string {\n    const /** @type {?} */ providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n/**\n * @return {?}\n */\ntoString(): string { return this.displayName; }\n}\n\nfunction ReflectiveInjector__tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._constructionCounter;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._providers;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._parent;\n/** @type {?} */\nReflectiveInjector_.prototype.keyIds;\n/** @type {?} */\nReflectiveInjector_.prototype.objs;\n}\n\n\nconst /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);\n/**\n * @param {?} injector\n * @param {?} fn\n * @return {?}\n */\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const /** @type {?} */ res: any[] = new Array(injector._providers.length);\n  for (let /** @type {?} */ i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}