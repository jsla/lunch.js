{"version":3,"file":"animation_parser.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/animation/animation_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileAnimationAnimateMetadata, CompileAnimationEntryMetadata, CompileAnimationGroupMetadata, CompileAnimationKeyframesSequenceMetadata, CompileAnimationMetadata, CompileAnimationSequenceMetadata, CompileAnimationStateDeclarationMetadata, CompileAnimationStateTransitionMetadata, CompileAnimationStyleMetadata, CompileAnimationWithStepsMetadata, CompileDirectiveMetadata, identifierName} from '../compile_metadata';\nimport {StringMapWrapper} from '../facade/collection';\nimport {isBlank, isPresent} from '../facade/lang';\nimport {CompilerInjectable} from '../injectable';\nimport {ParseError} from '../parse_util';\nimport {ANY_STATE, FILL_STYLE_FLAG} from '../private_import_core';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\n\nimport {AnimationAst, AnimationEntryAst, AnimationGroupAst, AnimationKeyframeAst, AnimationSequenceAst, AnimationStateDeclarationAst, AnimationStateTransitionAst, AnimationStateTransitionExpression, AnimationStepAst, AnimationStylesAst, AnimationWithStepsAst} from './animation_ast';\nimport {StylesCollection} from './styles_collection';\n\nconst /** @type {?} */ _INITIAL_KEYFRAME = 0;\nconst /** @type {?} */ _TERMINAL_KEYFRAME = 1;\nconst /** @type {?} */ _ONE_SECOND = 1000;\n\ndeclare type Styles = {\n  [key: string]: string | number\n};\nexport class AnimationParseError extends ParseError {\n/**\n * @param {?} message\n */\nconstructor(message: string) { super(null, message); }\n/**\n * @return {?}\n */\ntoString(): string { return `${this.msg}`; }\n}\nexport class AnimationEntryParseResult {\n/**\n * @param {?} ast\n * @param {?} errors\n */\nconstructor(public ast: AnimationEntryAst,\npublic errors: AnimationParseError[]) {}\n}\n\nfunction AnimationEntryParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationEntryParseResult.prototype.ast;\n/** @type {?} */\nAnimationEntryParseResult.prototype.errors;\n}\n\n@CompilerInjectable()\nexport class AnimationParser {\n/**\n * @param {?} _schema\n */\nconstructor(private _schema: ElementSchemaRegistry) {}\n/**\n * @param {?} component\n * @return {?}\n */\nparseComponent(component: CompileDirectiveMetadata): AnimationEntryAst[] {\n    const /** @type {?} */ errors: string[] = [];\n    const /** @type {?} */ componentName = identifierName(component.type);\n    const /** @type {?} */ animationTriggerNames = new Set<string>();\n    const /** @type {?} */ asts = component.template.animations.map(entry => {\n      const /** @type {?} */ result = this.parseEntry(entry);\n      const /** @type {?} */ ast = result.ast;\n      const /** @type {?} */ triggerName = ast.name;\n      if (animationTriggerNames.has(triggerName)) {\n        result.errors.push(new AnimationParseError(\n            `The animation trigger \"${triggerName}\" has already been registered for the ${componentName} component`));\n      } else {\n        animationTriggerNames.add(triggerName);\n      }\n      if (result.errors.length > 0) {\n        let /** @type {?} */ errorMessage =\n            `- Unable to parse the animation sequence for \"${triggerName}\" on the ${componentName} component due to the following errors:`;\n        result.errors.forEach(\n            (error: AnimationParseError) => { errorMessage += '\\n-- ' + error.msg; });\n        errors.push(errorMessage);\n      }\n      return ast;\n    });\n\n    if (errors.length > 0) {\n      const /** @type {?} */ errorString = errors.join('\\n');\n      throw new Error(`Animation parse errors:\\n${errorString}`);\n    }\n\n    return asts;\n  }\n/**\n * @param {?} entry\n * @return {?}\n */\nparseEntry(entry: CompileAnimationEntryMetadata): AnimationEntryParseResult {\n    const /** @type {?} */ errors: AnimationParseError[] = [];\n    const /** @type {?} */ stateStyles: {[key: string]: AnimationStylesAst} = {};\n    const /** @type {?} */ transitions: CompileAnimationStateTransitionMetadata[] = [];\n\n    const /** @type {?} */ stateDeclarationAsts: AnimationStateDeclarationAst[] = [];\n    entry.definitions.forEach(def => {\n      if (def instanceof CompileAnimationStateDeclarationMetadata) {\n        _parseAnimationDeclarationStates(def, this._schema, errors).forEach(ast => {\n          stateDeclarationAsts.push(ast);\n          stateStyles[ast.stateName] = ast.styles;\n        });\n      } else {\n        transitions.push( /** @type {?} */((<CompileAnimationStateTransitionMetadata>def)));\n      }\n    });\n\n    const /** @type {?} */ stateTransitionAsts = transitions.map(\n        transDef => _parseAnimationStateTransition(transDef, stateStyles, this._schema, errors));\n\n    const /** @type {?} */ ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);\n    return new AnimationEntryParseResult(ast, errors);\n  }\n}\n\nfunction AnimationParser_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationParser.prototype._schema;\n}\n\n/**\n * @param {?} stateMetadata\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationDeclarationStates(\n    stateMetadata: CompileAnimationStateDeclarationMetadata, schema: ElementSchemaRegistry,\n    errors: AnimationParseError[]): AnimationStateDeclarationAst[] {\n  const /** @type {?} */ normalizedStyles = _normalizeStyleMetadata(stateMetadata.styles, {}, schema, errors, false);\n  const /** @type {?} */ defStyles = new AnimationStylesAst(normalizedStyles);\n  const /** @type {?} */ states = stateMetadata.stateNameExpr.split(/\\s*,\\s*/);\n  return states.map(state => new AnimationStateDeclarationAst(state, defStyles));\n}\n/**\n * @param {?} transitionStateMetadata\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationStateTransition(\n    transitionStateMetadata: CompileAnimationStateTransitionMetadata,\n    stateStyles: {[key: string]: AnimationStylesAst}, schema: ElementSchemaRegistry,\n    errors: AnimationParseError[]): AnimationStateTransitionAst {\n  const /** @type {?} */ styles = new StylesCollection();\n  const /** @type {?} */ transitionExprs: AnimationStateTransitionExpression[] = [];\n  const /** @type {?} */ transitionStates = transitionStateMetadata.stateChangeExpr.split(/\\s*,\\s*/);\n  transitionStates.forEach(\n      expr => { transitionExprs.push(..._parseAnimationTransitionExpr(expr, errors)); });\n  const /** @type {?} */ entry = _normalizeAnimationEntry(transitionStateMetadata.steps);\n  const /** @type {?} */ animation = _normalizeStyleSteps(entry, stateStyles, schema, errors);\n  const /** @type {?} */ animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);\n  if (errors.length == 0) {\n    _fillAnimationAstStartingKeyframes(animationAst, styles, errors);\n  }\n\n  const /** @type {?} */ stepsAst: AnimationWithStepsAst = (animationAst instanceof AnimationWithStepsAst) ?\n      animationAst :\n      new AnimationSequenceAst([animationAst]);\n\n  return new AnimationStateTransitionAst(transitionExprs, stepsAst);\n}\n/**\n * @param {?} alias\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationAlias(alias: string, errors: AnimationParseError[]): string {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    default:\n      errors.push(\n          new AnimationParseError(`the transition alias value \"${alias}\" is not supported`));\n      return '* => *';\n  }\n}\n/**\n * @param {?} eventStr\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationTransitionExpr(\n    eventStr: string, errors: AnimationParseError[]): AnimationStateTransitionExpression[] {\n  const /** @type {?} */ expressions: AnimationStateTransitionExpression[] = [];\n  if (eventStr[0] == ':') {\n    eventStr = _parseAnimationAlias(eventStr, errors);\n  }\n  const /** @type {?} */ match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (!isPresent(match) || match.length < 4) {\n    errors.push(new AnimationParseError(`the provided ${eventStr} is not of a supported format`));\n    return expressions;\n  }\n\n  const /** @type {?} */ fromState = match[1];\n  const /** @type {?} */ separator = match[2];\n  const /** @type {?} */ toState = match[3];\n  expressions.push(new AnimationStateTransitionExpression(fromState, toState));\n\n  const /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(new AnimationStateTransitionExpression(toState, fromState));\n  }\n  return expressions;\n}\n/**\n * @param {?} entry\n * @return {?}\n */\nfunction _normalizeAnimationEntry(entry: CompileAnimationMetadata | CompileAnimationMetadata[]):\n    CompileAnimationMetadata {\n  return Array.isArray(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;\n}\n/**\n * @param {?} entry\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @param {?} permitStateReferences\n * @return {?}\n */\nfunction _normalizeStyleMetadata(\n    entry: CompileAnimationStyleMetadata, stateStyles: {[key: string]: AnimationStylesAst},\n    schema: ElementSchemaRegistry, errors: AnimationParseError[],\n    permitStateReferences: boolean): {[key: string]: string | number}[] {\n  const /** @type {?} */ offset = entry.offset;\n  if (offset > 1 || offset < 0) {\n    errors.push(new AnimationParseError(`Offset values for animations must be between 0 and 1`));\n  }\n\n  const /** @type {?} */ normalizedStyles: {[key: string]: string | number}[] = [];\n  entry.styles.forEach(styleEntry => {\n    if (typeof styleEntry === 'string') {\n      if (permitStateReferences) {\n        normalizedStyles.push(..._resolveStylesFromState( /** @type {?} */((<string>styleEntry)), stateStyles, errors));\n      } else {\n        errors.push(new AnimationParseError(\n            `State based animations cannot contain references to other states`));\n      }\n    } else {\n      const /** @type {?} */ stylesObj = /** @type {?} */(( <Styles>styleEntry));\n      const /** @type {?} */ normalizedStylesObj: Styles = {};\n      Object.keys(stylesObj).forEach(propName => {\n        const /** @type {?} */ normalizedProp = schema.normalizeAnimationStyleProperty(propName);\n        const /** @type {?} */ normalizedOutput =\n            schema.normalizeAnimationStyleValue(normalizedProp, propName, stylesObj[propName]);\n        const /** @type {?} */ normalizationError = normalizedOutput['error'];\n        if (normalizationError) {\n          errors.push(new AnimationParseError(normalizationError));\n        }\n        normalizedStylesObj[normalizedProp] = normalizedOutput['value'];\n      });\n      normalizedStyles.push(normalizedStylesObj);\n    }\n  });\n  return normalizedStyles;\n}\n/**\n * @param {?} entry\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _normalizeStyleSteps(\n    entry: CompileAnimationMetadata, stateStyles: {[key: string]: AnimationStylesAst},\n    schema: ElementSchemaRegistry, errors: AnimationParseError[]): CompileAnimationMetadata {\n  const /** @type {?} */ steps = _normalizeStyleStepEntry(entry, stateStyles, schema, errors);\n  return (entry instanceof CompileAnimationGroupMetadata) ?\n      new CompileAnimationGroupMetadata(steps) :\n      new CompileAnimationSequenceMetadata(steps);\n}\n/**\n * @param {?} stylesList\n * @param {?} newItem\n * @return {?}\n */\nfunction _mergeAnimationStyles(\n    stylesList: any[], newItem: {[key: string]: string | number} | string) {\n  if (typeof newItem === 'object' && newItem !== null && stylesList.length > 0) {\n    const /** @type {?} */ lastIndex = stylesList.length - 1;\n    const /** @type {?} */ lastItem = stylesList[lastIndex];\n    if (typeof lastItem === 'object' && lastItem !== null) {\n      stylesList[lastIndex] = StringMapWrapper.merge( /** @type {?} */((\n          <{[key: string]: string | number}>lastItem)), /** @type {?} */(( <{[key: string]: string | number}>newItem)));\n      return;\n    }\n  }\n  stylesList.push(newItem);\n}\n/**\n * @param {?} entry\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _normalizeStyleStepEntry(\n    entry: CompileAnimationMetadata, stateStyles: {[key: string]: AnimationStylesAst},\n    schema: ElementSchemaRegistry, errors: AnimationParseError[]): CompileAnimationMetadata[] {\n  let /** @type {?} */ steps: CompileAnimationMetadata[];\n  if (entry instanceof CompileAnimationWithStepsMetadata) {\n    steps = entry.steps;\n  } else {\n    return [entry];\n  }\n\n  const /** @type {?} */ newSteps: CompileAnimationMetadata[] = [];\n  let /** @type {?} */ combinedStyles: Styles[];\n  steps.forEach(step => {\n    if (step instanceof CompileAnimationStyleMetadata) {\n      // this occurs when a style step is followed by a previous style step\n      // or when the first style step is run. We want to concatenate all subsequent\n      // style steps together into a single style step such that we have the correct\n      // starting keyframe data to pass into the animation player.\n      if (!isPresent(combinedStyles)) {\n        combinedStyles = [];\n      }\n      _normalizeStyleMetadata( /** @type {?} */((\n          <CompileAnimationStyleMetadata>step)), stateStyles, schema, errors, true)\n          .forEach(entry => { _mergeAnimationStyles(combinedStyles, entry); });\n    } else {\n      // it is important that we create a metadata entry of the combined styles\n      // before we go on an process the animate, sequence or group metadata steps.\n      // This will ensure that the AST will have the previous styles painted on\n      // screen before any further animations that use the styles take place.\n      if (isPresent(combinedStyles)) {\n        newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));\n        combinedStyles = null;\n      }\n\n      if (step instanceof CompileAnimationAnimateMetadata) {\n        // we do not recurse into CompileAnimationAnimateMetadata since\n        // those style steps are not going to be squashed\n        const /** @type {?} */ animateStyleValue = ( /** @type {?} */((<CompileAnimationAnimateMetadata>step))).styles;\n        if (animateStyleValue instanceof CompileAnimationStyleMetadata) {\n          animateStyleValue.styles =\n              _normalizeStyleMetadata(animateStyleValue, stateStyles, schema, errors, true);\n        } else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {\n          animateStyleValue.steps.forEach(step => {\n            step.styles = _normalizeStyleMetadata(step, stateStyles, schema, errors, true);\n          });\n        }\n      } else if (step instanceof CompileAnimationWithStepsMetadata) {\n        const /** @type {?} */ innerSteps = _normalizeStyleStepEntry(step, stateStyles, schema, errors);\n        step = step instanceof CompileAnimationGroupMetadata ?\n            new CompileAnimationGroupMetadata(innerSteps) :\n            new CompileAnimationSequenceMetadata(innerSteps);\n      }\n\n      newSteps.push(step);\n    }\n  });\n\n  // this happens when only styles were animated within the sequence\n  if (isPresent(combinedStyles)) {\n    newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));\n  }\n\n  return newSteps;\n}\n/**\n * @param {?} stateName\n * @param {?} stateStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _resolveStylesFromState(\n    stateName: string, stateStyles: {[key: string]: AnimationStylesAst},\n    errors: AnimationParseError[]) {\n  const /** @type {?} */ styles: Styles[] = [];\n  if (stateName[0] != ':') {\n    errors.push(new AnimationParseError(`Animation states via styles must be prefixed with a \":\"`));\n  } else {\n    const /** @type {?} */ normalizedStateName = stateName.substring(1);\n    const /** @type {?} */ value = stateStyles[normalizedStateName];\n    if (!isPresent(value)) {\n      errors.push(new AnimationParseError(\n          `Unable to apply styles due to missing a state: \"${normalizedStateName}\"`));\n    } else {\n      value.styles.forEach(stylesEntry => {\n        if (typeof stylesEntry === 'object' && stylesEntry !== null) {\n          styles.push( /** @type {?} */((stylesEntry as Styles)));\n        }\n      });\n    }\n  }\n  return styles;\n}\nclass _AnimationTimings {\n/**\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n */\nconstructor(public duration: number,\npublic delay: number,\npublic easing: string) {}\n}\n\nfunction _AnimationTimings_tsickle_Closure_declarations() {\n/** @type {?} */\n_AnimationTimings.prototype.duration;\n/** @type {?} */\n_AnimationTimings.prototype.delay;\n/** @type {?} */\n_AnimationTimings.prototype.easing;\n}\n\n/**\n * @param {?} keyframeSequence\n * @param {?} currentTime\n * @param {?} collectedStyles\n * @param {?} stateStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationKeyframes(\n    keyframeSequence: CompileAnimationKeyframesSequenceMetadata, currentTime: number,\n    collectedStyles: StylesCollection, stateStyles: {[key: string]: AnimationStylesAst},\n    errors: AnimationParseError[]): AnimationKeyframeAst[] {\n  const /** @type {?} */ totalEntries = keyframeSequence.steps.length;\n  let /** @type {?} */ totalOffsets = 0;\n  keyframeSequence.steps.forEach(step => totalOffsets += (isPresent(step.offset) ? 1 : 0));\n\n  if (totalOffsets > 0 && totalOffsets < totalEntries) {\n    errors.push(new AnimationParseError(\n        `Not all style() entries contain an offset for the provided keyframe()`));\n    totalOffsets = totalEntries;\n  }\n\n  let /** @type {?} */ limit = totalEntries - 1;\n  const /** @type {?} */ margin = totalOffsets == 0 ? (1 / limit) : 0;\n  const /** @type {?} */ rawKeyframes: any[] /** TODO #9100 */ = [];\n  let /** @type {?} */ index = 0;\n  let /** @type {?} */ doSortKeyframes = false;\n  let /** @type {?} */ lastOffset = 0;\n  keyframeSequence.steps.forEach(styleMetadata => {\n    let /** @type {?} */ offset = styleMetadata.offset;\n    const /** @type {?} */ keyframeStyles: Styles = {};\n    styleMetadata.styles.forEach(entry => {\n      Object.keys(entry).forEach(prop => {\n        if (prop != 'offset') {\n          keyframeStyles[prop] = ( /** @type {?} */((entry as Styles)))[prop];\n        }\n      });\n    });\n\n    if (isPresent(offset)) {\n      doSortKeyframes = doSortKeyframes || (offset < lastOffset);\n    } else {\n      offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);\n    }\n\n    rawKeyframes.push([offset, keyframeStyles]);\n    lastOffset = offset;\n    index++;\n  });\n\n  if (doSortKeyframes) {\n    rawKeyframes.sort((a, b) => a[0] <= b[0] ? -1 : 1);\n  }\n\n  let /** @type {?} */ firstKeyframe = rawKeyframes[0];\n  if (firstKeyframe[0] != _INITIAL_KEYFRAME) {\n    rawKeyframes.splice(0, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);\n  }\n\n  const /** @type {?} */ firstKeyframeStyles = firstKeyframe[1];\n  limit = rawKeyframes.length - 1;\n  let /** @type {?} */ lastKeyframe = rawKeyframes[limit];\n  if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {\n    rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);\n    limit++;\n  }\n\n  const /** @type {?} */ lastKeyframeStyles = lastKeyframe[1];\n  for (let /** @type {?} */ i = 1; i <= limit; i++) {\n    const /** @type {?} */ entry = rawKeyframes[i];\n    const /** @type {?} */ styles = entry[1];\n\n    Object.keys(styles).forEach(prop => {\n      if (!isPresent(firstKeyframeStyles[prop])) {\n        firstKeyframeStyles[prop] = FILL_STYLE_FLAG;\n      }\n    });\n  }\n\n  for (let /** @type {?} */ i = limit - 1; i >= 0; i--) {\n    const /** @type {?} */ entry = rawKeyframes[i];\n    const /** @type {?} */ styles = entry[1];\n\n    Object.keys(styles).forEach(prop => {\n      if (!isPresent(lastKeyframeStyles[prop])) {\n        lastKeyframeStyles[prop] = styles[prop];\n      }\n    });\n  }\n\n  return rawKeyframes.map(\n      entry => new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])));\n}\n/**\n * @param {?} entry\n * @param {?} currentTime\n * @param {?} collectedStyles\n * @param {?} stateStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _parseTransitionAnimation(\n    entry: CompileAnimationMetadata, currentTime: number, collectedStyles: StylesCollection,\n    stateStyles: {[key: string]: AnimationStylesAst}, errors: AnimationParseError[]): AnimationAst {\n  let /** @type {?} */ ast: any /** TODO #9100 */;\n  let /** @type {?} */ playTime = 0;\n  const /** @type {?} */ startingTime = currentTime;\n  if (entry instanceof CompileAnimationWithStepsMetadata) {\n    let /** @type {?} */ maxDuration = 0;\n    const /** @type {?} */ steps: any[] /** TODO #9100 */ = [];\n    const /** @type {?} */ isGroup = entry instanceof CompileAnimationGroupMetadata;\n    let /** @type {?} */ previousStyles: any /** TODO #9100 */;\n    entry.steps.forEach(entry => {\n      // these will get picked up by the next step...\n      const /** @type {?} */ time = isGroup ? startingTime : currentTime;\n      if (entry instanceof CompileAnimationStyleMetadata) {\n        entry.styles.forEach(stylesEntry => {\n          // by this point we know that we only have stringmap values\n          const /** @type {?} */ map = /** @type {?} */(( stylesEntry as Styles));\n          Object.keys(map).forEach(\n              prop => { collectedStyles.insertAtTime(prop, time, map[prop]); });\n        });\n        previousStyles = entry.styles;\n        return;\n      }\n\n      const /** @type {?} */ innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);\n      if (isPresent(previousStyles)) {\n        if (entry instanceof CompileAnimationWithStepsMetadata) {\n          const /** @type {?} */ startingStyles = new AnimationStylesAst(previousStyles);\n          steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));\n        } else {\n          const /** @type {?} */ innerStep = /** @type {?} */(( <AnimationStepAst>innerAst));\n          innerStep.startingStyles.styles.push(...previousStyles);\n        }\n        previousStyles = null;\n      }\n\n      const /** @type {?} */ astDuration = innerAst.playTime;\n      currentTime += astDuration;\n      playTime += astDuration;\n      maxDuration = Math.max(astDuration, maxDuration);\n      steps.push(innerAst);\n    });\n    if (isPresent(previousStyles)) {\n      const /** @type {?} */ startingStyles = new AnimationStylesAst(previousStyles);\n      steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));\n    }\n    if (isGroup) {\n      ast = new AnimationGroupAst(steps);\n      playTime = maxDuration;\n      currentTime = startingTime + playTime;\n    } else {\n      ast = new AnimationSequenceAst(steps);\n    }\n  } else if (entry instanceof CompileAnimationAnimateMetadata) {\n    const /** @type {?} */ timings = _parseTimeExpression(entry.timings, errors);\n    const /** @type {?} */ styles = entry.styles;\n\n    let /** @type {?} */ keyframes: any /** TODO #9100 */;\n    if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {\n      keyframes =\n          _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);\n    } else {\n      const /** @type {?} */ styleData = /** @type {?} */(( <CompileAnimationStyleMetadata>styles));\n      const /** @type {?} */ offset = _TERMINAL_KEYFRAME;\n      const /** @type {?} */ styleAst = new AnimationStylesAst( /** @type {?} */((styleData.styles as Styles[])));\n      const /** @type {?} */ keyframe = new AnimationKeyframeAst(offset, styleAst);\n      keyframes = [keyframe];\n    }\n\n    ast = new AnimationStepAst(\n        new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);\n    playTime = timings.duration + timings.delay;\n    currentTime += playTime;\n\n    keyframes.forEach(\n        (keyframe: any /** TODO #9100 */) => keyframe.styles.styles.forEach(\n            (entry: any /** TODO #9100 */) => Object.keys(entry).forEach(\n                prop => { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); })));\n  } else {\n    // if the code reaches this stage then an error\n    // has already been populated within the _normalizeStyleSteps()\n    // operation...\n    ast = new AnimationStepAst(null, [], 0, 0, '');\n  }\n\n  ast.playTime = playTime;\n  ast.startTime = startingTime;\n  return ast;\n}\n/**\n * @param {?} ast\n * @param {?} collectedStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _fillAnimationAstStartingKeyframes(\n    ast: AnimationAst, collectedStyles: StylesCollection, errors: AnimationParseError[]): void {\n  // steps that only contain style will not be filled\n  if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {\n    const /** @type {?} */ keyframes = ast.keyframes;\n    if (keyframes.length == 1) {\n      const /** @type {?} */ endKeyframe = keyframes[0];\n      const /** @type {?} */ startKeyframe = _createStartKeyframeFromEndKeyframe(\n          endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);\n      ast.keyframes = [startKeyframe, endKeyframe];\n    }\n  } else if (ast instanceof AnimationWithStepsAst) {\n    ast.steps.forEach(entry => _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors));\n  }\n}\n/**\n * @param {?} exp\n * @param {?} errors\n * @return {?}\n */\nfunction _parseTimeExpression(\n    exp: string | number, errors: AnimationParseError[]): _AnimationTimings {\n  const /** @type {?} */ regex = /^([\\.\\d]+)(m?s)(?:\\s+([\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?/i;\n  let /** @type {?} */ duration: number;\n  let /** @type {?} */ delay: number = 0;\n  let /** @type {?} */ easing: string = null;\n  if (typeof exp === 'string') {\n    const /** @type {?} */ matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(new AnimationParseError(`The provided timing value \"${exp}\" is invalid.`));\n      return new _AnimationTimings(0, 0, null);\n    }\n\n    let /** @type {?} */ durationMatch = parseFloat(matches[1]);\n    const /** @type {?} */ durationUnit = matches[2];\n    if (durationUnit == 's') {\n      durationMatch *= _ONE_SECOND;\n    }\n    duration = Math.floor(durationMatch);\n\n    const /** @type {?} */ delayMatch = matches[3];\n    const /** @type {?} */ delayUnit = matches[4];\n    if (isPresent(delayMatch)) {\n      let /** @type {?} */ delayVal: number = parseFloat(delayMatch);\n      if (isPresent(delayUnit) && delayUnit == 's') {\n        delayVal *= _ONE_SECOND;\n      }\n      delay = Math.floor(delayVal);\n    }\n\n    const /** @type {?} */ easingVal = matches[5];\n    if (!isBlank(easingVal)) {\n      easing = easingVal;\n    }\n  } else {\n    duration = /** @type {?} */(( <number>exp));\n  }\n\n  return new _AnimationTimings(duration, delay, easing);\n}\n/**\n * @param {?} endKeyframe\n * @param {?} startTime\n * @param {?} duration\n * @param {?} collectedStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _createStartKeyframeFromEndKeyframe(\n    endKeyframe: AnimationKeyframeAst, startTime: number, duration: number,\n    collectedStyles: StylesCollection, errors: AnimationParseError[]): AnimationKeyframeAst {\n  const /** @type {?} */ values: Styles = {};\n  const /** @type {?} */ endTime = startTime + duration;\n  endKeyframe.styles.styles.forEach((styleData: Styles) => {\n    Object.keys(styleData).forEach(prop => {\n      const /** @type {?} */ val = styleData[prop];\n      if (prop == 'offset') return;\n\n      const /** @type {?} */ resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);\n      let /** @type {?} */ resultEntry: any /** TODO #9100 */, /** @type {?} */ nextEntry: any /** TODO #9100 */, /** @type {?} */\n          value: any /** TODO #9100 */;\n      if (isPresent(resultIndex)) {\n        resultEntry = collectedStyles.getByIndex(prop, resultIndex);\n        value = resultEntry.value;\n        nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);\n      } else {\n        // this is a flag that the runtime code uses to pass\n        // in a value either from the state declaration styles\n        // or using the AUTO_STYLE value (e.g. getComputedStyle)\n        value = FILL_STYLE_FLAG;\n      }\n\n      if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {\n        errors.push(new AnimationParseError(\n            `The animated CSS property \"${prop}\" unexpectedly changes between steps \"${resultEntry.time}ms\" and \"${endTime}ms\" at \"${nextEntry.time}ms\"`));\n      }\n\n      values[prop] = value;\n    });\n  });\n\n  return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}