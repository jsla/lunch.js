{"version":3,"file":"property_binder.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/view_compiler/property_binder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '@angular/core';\n\nimport {createCheckBindingField, createCheckBindingStmt} from '../compiler_util/binding_util';\nimport {ConvertPropertyBindingResult, convertPropertyBinding} from '../compiler_util/expression_converter';\nimport {createEnumExpression} from '../compiler_util/identifier_util';\nimport {triggerAnimation, writeToRenderer} from '../compiler_util/render_util';\nimport {DirectiveWrapperExpressions} from '../directive_wrapper_compiler';\nimport {Identifiers, createIdentifier} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {isDefaultChangeDetectionStrategy} from '../private_import_core';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, PropertyBindingType} from '../template_parser/template_ast';\nimport {CompileElement, CompileNode} from './compile_element';\nimport {CompileView} from './compile_view';\nimport {DetectChangesVars} from './constants';\nimport {getHandleEventMethodName} from './util';\n/**\n * @param {?} boundText\n * @param {?} compileNode\n * @param {?} view\n * @return {?}\n */\nexport function bindRenderText(\n    boundText: BoundTextAst, compileNode: CompileNode, view: CompileView): void {\n  const /** @type {?} */ valueField = createCheckBindingField(view);\n  const /** @type {?} */ evalResult = convertPropertyBinding(\n      view, view, view.componentContext, boundText.value, valueField.bindingId);\n  if (!evalResult) {\n    return null;\n  }\n\n  view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);\n  view.detectChangesRenderPropertiesMethod.addStmts(createCheckBindingStmt(\n      evalResult, valueField.expression, DetectChangesVars.throwOnChange,\n      [o.THIS_EXPR.prop('renderer')\n           .callMethod('setText', [compileNode.renderNode, evalResult.currValExpr])\n           .toStmt()]));\n}\n/**\n * @param {?} boundProps\n * @param {?} boundOutputs\n * @param {?} hasEvents\n * @param {?} compileElement\n * @return {?}\n */\nexport function bindRenderInputs(\n    boundProps: BoundElementPropertyAst[], boundOutputs: BoundEventAst[], hasEvents: boolean,\n    compileElement: CompileElement) {\n  const /** @type {?} */ view = compileElement.view;\n  const /** @type {?} */ renderNode = compileElement.renderNode;\n\n  boundProps.forEach((boundProp) => {\n    const /** @type {?} */ bindingField = createCheckBindingField(view);\n    view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);\n    const /** @type {?} */ evalResult = convertPropertyBinding(\n        view, view, compileElement.view.componentContext, boundProp.value, bindingField.bindingId);\n    if (!evalResult) {\n      return;\n    }\n    const /** @type {?} */ checkBindingStmts: o.Statement[] = [];\n    let /** @type {?} */ compileMethod = view.detectChangesRenderPropertiesMethod;\n    switch (boundProp.type) {\n      case PropertyBindingType.Property:\n      case PropertyBindingType.Attribute:\n      case PropertyBindingType.Class:\n      case PropertyBindingType.Style:\n        checkBindingStmts.push(...writeToRenderer(\n            o.THIS_EXPR, boundProp, renderNode, evalResult.currValExpr,\n            view.genConfig.logBindingUpdate));\n        break;\n      case PropertyBindingType.Animation:\n        compileMethod = view.animationBindingsMethod;\n        const {updateStmts, detachStmts} = triggerAnimation(\n            o.THIS_EXPR, o.THIS_EXPR, boundProp, boundOutputs,\n            (hasEvents ? o.THIS_EXPR.prop(getHandleEventMethodName(compileElement.nodeIndex)) :\n                         o.importExpr(createIdentifier(Identifiers.noop)))\n                .callMethod(o.BuiltinMethod.Bind, [o.THIS_EXPR]),\n            compileElement.renderNode, evalResult.currValExpr, bindingField.expression);\n        checkBindingStmts.push(...updateStmts);\n        view.detachMethod.addStmts(detachStmts);\n        break;\n    }\n    compileMethod.addStmts(createCheckBindingStmt(\n        evalResult, bindingField.expression, DetectChangesVars.throwOnChange, checkBindingStmts));\n  });\n}\n/**\n * @param {?} directiveAst\n * @param {?} directiveWrapperInstance\n * @param {?} compileElement\n * @param {?} elementName\n * @param {?} schemaRegistry\n * @return {?}\n */\nexport function bindDirectiveHostProps(\n    directiveAst: DirectiveAst, directiveWrapperInstance: o.Expression,\n    compileElement: CompileElement, elementName: string,\n    schemaRegistry: ElementSchemaRegistry): void {\n  // We need to provide the SecurityContext for properties that could need sanitization.\n  const /** @type {?} */ runtimeSecurityCtxExprs =\n      directiveAst.hostProperties.filter(boundProp => boundProp.needsRuntimeSecurityContext)\n          .map((boundProp) => {\n            let /** @type {?} */ ctx: SecurityContext;\n            switch (boundProp.type) {\n              case PropertyBindingType.Property:\n                ctx = schemaRegistry.securityContext(elementName, boundProp.name, false);\n                break;\n              case PropertyBindingType.Attribute:\n                ctx = schemaRegistry.securityContext(elementName, boundProp.name, true);\n                break;\n              default:\n                throw new Error(\n                    `Illegal state: Only property / attribute bindings can have an unknown security context! Binding ${boundProp.name}`);\n            }\n            return createEnumExpression(Identifiers.SecurityContext, ctx);\n          });\n  compileElement.view.detectChangesRenderPropertiesMethod.addStmts(\n      DirectiveWrapperExpressions.checkHost(\n          directiveAst.hostProperties, directiveWrapperInstance, o.THIS_EXPR,\n          compileElement.compViewExpr || o.THIS_EXPR, compileElement.renderNode,\n          DetectChangesVars.throwOnChange, runtimeSecurityCtxExprs));\n}\n/**\n * @param {?} directiveAst\n * @param {?} directiveWrapperInstance\n * @param {?} dirIndex\n * @param {?} compileElement\n * @return {?}\n */\nexport function bindDirectiveInputs(\n    directiveAst: DirectiveAst, directiveWrapperInstance: o.Expression, dirIndex: number,\n    compileElement: CompileElement) {\n  const /** @type {?} */ view = compileElement.view;\n  const /** @type {?} */ detectChangesInInputsMethod = view.detectChangesInInputsMethod;\n  detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n\n  directiveAst.inputs.forEach((input, inputIdx) => {\n    // Note: We can't use `fields.length` here, as we are not adding a field!\n    const /** @type {?} */ bindingId = `${compileElement.nodeIndex}_${dirIndex}_${inputIdx}`;\n    detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);\n    const /** @type {?} */ evalResult =\n        convertPropertyBinding(view, view, view.componentContext, input.value, bindingId);\n    if (!evalResult) {\n      return;\n    }\n    detectChangesInInputsMethod.addStmts(evalResult.stmts);\n    detectChangesInInputsMethod.addStmt(\n        directiveWrapperInstance\n            .callMethod(\n                `check_${input.directiveName}`,\n                [\n                  evalResult.currValExpr, DetectChangesVars.throwOnChange,\n                  evalResult.forceUpdate || o.literal(false)\n                ])\n            .toStmt());\n  });\n  const /** @type {?} */ isOnPushComp = directiveAst.directive.isComponent &&\n      !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);\n  const /** @type {?} */ directiveDetectChangesExpr = DirectiveWrapperExpressions.ngDoCheck(\n      directiveWrapperInstance, o.THIS_EXPR, compileElement.renderNode,\n      DetectChangesVars.throwOnChange);\n  const /** @type {?} */ directiveDetectChangesStmt = isOnPushComp ?\n      new o.IfStmt(\n          directiveDetectChangesExpr,\n          [compileElement.compViewExpr.callMethod('markAsCheckOnce', []).toStmt()]) :\n      directiveDetectChangesExpr.toStmt();\n  detectChangesInInputsMethod.addStmt(directiveDetectChangesStmt);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}