{"version":3,"file":"static_symbol_resolver.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nexport class ResolvedStaticSymbol {\n/**\n * @param {?} symbol\n * @param {?} metadata\n */\nconstructor(public symbol: StaticSymbol,\npublic metadata: any) {}\n}\n\nfunction ResolvedStaticSymbol_tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedStaticSymbol.prototype.symbol;\n/** @type {?} */\nResolvedStaticSymbol.prototype.metadata;\n}\n\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular 2 CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[];\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile: string): string /*|null*/;\n}\n\nconst /** @type {?} */ SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n */\nexport class StaticSymbolResolver {\nprivate metadataCache = new Map<string, {[key: string]: any}>();\nprivate resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\nprivate resolvedFilePaths = new Set<string>();\n/**\n * @param {?} host\n * @param {?} staticSymbolCache\n * @param {?} summaryResolver\n * @param {?=} errorRecorder\n */\nconstructor(\nprivate host: StaticSymbolResolverHost,\nprivate staticSymbolCache: StaticSymbolCache,\nprivate summaryResolver: SummaryResolver<StaticSymbol>,\nprivate errorRecorder?: (error: any, fileName: string) => void) {}\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nresolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol);\n    }\n    let /** @type {?} */ result = this._resolveSymbolFromSummary(staticSymbol);\n    if (!result) {\n      // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n      // have summaries, only .d.ts files. So we always need to check both, the summary\n      // and metadata.\n      this._createSymbolsOf(staticSymbol.filePath);\n      result = this.resolvedSymbols.get(staticSymbol);\n    }\n    return result;\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nprivate _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    const /** @type {?} */ members = staticSymbol.members;\n    const /** @type {?} */ baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    const /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let /** @type {?} */ value = baseMetadata;\n      for (let /** @type {?} */ i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nprivate _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    const /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n/**\n * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n * All types passed to the StaticResolver should be pseudo-types returned by this method.\n * \n * @param {?} declarationFile the absolute path of the file where the symbol is declared\n * @param {?} name the name of the type.\n * @param {?=} members\n * @return {?}\n */\ngetStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\ngetSymbolsOf(filePath: string): StaticSymbol[] {\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    let /** @type {?} */ symbols = new Set<StaticSymbol>(this.summaryResolver.getSymbolsOf(filePath));\n    this._createSymbolsOf(filePath);\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        symbols.add(resolvedSymbol.symbol);\n      }\n    });\n    return Array.from(symbols);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\nprivate _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const /** @type {?} */ resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      Object.keys(metadata['metadata']).forEach((symbolName) => {\n        const /** @type {?} */ symbolMeta = metadata['metadata'][symbolName];\n        resolvedSymbols.push(\n            this.createResolvedSymbol(this.getStaticSymbol(filePath, symbolName), symbolMeta));\n      });\n    }\n\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const /** @type {?} */ moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let /** @type {?} */ symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            let /** @type {?} */ symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = exportSymbol.name;\n            }\n            const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const /** @type {?} */ targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(new ResolvedStaticSymbol(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const /** @type {?} */ nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(new ResolvedStaticSymbol(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} metadata\n * @return {?}\n */\nprivate createResolvedSymbol(sourceSymbol: StaticSymbol, metadata: any): ResolvedStaticSymbol {\n    const /** @type {?} */ self = this;\nclass ReferenceTransformer extends ValueTransformer {\n/**\n * @param {?} map\n * @param {?} functionParams\n * @return {?}\n */\nvisitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const /** @type {?} */ symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const /** @type {?} */ oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const /** @type {?} */ result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const /** @type {?} */ module = map['module'];\n          const /** @type {?} */ name = map['name'];\n          if (!name) {\n            return null;\n          }\n          let /** @type {?} */ filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath);\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`\n              };\n            }\n          } else {\n            const /** @type {?} */ isFunctionParam = functionParams.indexOf(name) >= 0;\n            if (!isFunctionParam) {\n              filePath = sourceSymbol.filePath;\n            }\n          }\n          if (filePath) {\n            return self.getStaticSymbol(filePath, name);\n          } else {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          }\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n\n    const /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n/**\n * @param {?} error\n * @param {?} context\n * @param {?=} path\n * @return {?}\n */\nprivate reportError(error: Error, context: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n/**\n * @param {?} module an absolute path to a module file.\n * @return {?}\n */\nprivate getModuleMetadata(module: string): {[key: string]: any} {\n    let /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let /** @type {?} */ maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage), null);\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n/**\n * @param {?} module\n * @param {?} symbolName\n * @param {?=} containingFile\n * @return {?}\n */\ngetSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ` relative to $ {\n            containingFile\n          } `: ''}`),\n          null);\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n/**\n * @param {?} module\n * @param {?} containingFile\n * @return {?}\n */\nprivate resolveModule(module: string, containingFile: string): string {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch ( /** @type {?} */e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(new e, null, containingFile);\n    }\n  }\n}\n\nfunction StaticSymbolResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nStaticSymbolResolver.prototype.metadataCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedSymbols;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedFilePaths;\n/** @type {?} */\nStaticSymbolResolver.prototype.host;\n/** @type {?} */\nStaticSymbolResolver.prototype.staticSymbolCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.summaryResolver;\n/** @type {?} */\nStaticSymbolResolver.prototype.errorRecorder;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}