{"version":3,"file":"model.js","sourceRoot":"","sources":["../../../../modules/@angular/forms/src/model.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {fromPromise} from 'rxjs/observable/fromPromise';\n\nimport {composeAsyncValidators, composeValidators} from './directives/shared';\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {EventEmitter, Observable} from './facade/async';\nimport {isObservable, isPromise} from './private_import_core';\n\n\n\n/**\n * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.\n */\nexport const /** @type {?} */ VALID = 'VALID';\n\n/**\n * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.\n */\nexport const /** @type {?} */ INVALID = 'INVALID';\n\n/**\n * Indicates that a FormControl is pending, i.e. that async validation is occurring and\n * errors are not yet available for the input value.\n */\nexport const /** @type {?} */ PENDING = 'PENDING';\n\n/**\n * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor\n * calculations of validity or value.\n */\nexport const /** @type {?} */ DISABLED = 'DISABLED';\n/**\n * @param {?} control\n * @param {?} path\n * @param {?} delimiter\n * @return {?}\n */\nfunction _find(control: AbstractControl, path: Array<string|number>| string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!(path instanceof Array)) {\n    path = ( /** @type {?} */((<string>path))).split(delimiter);\n  }\n  if (path instanceof Array && (path.length === 0)) return null;\n\n  return ( /** @type {?} */((<Array<string|number>>path))).reduce((v, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls[name] || null;\n    }\n\n    if (v instanceof FormArray) {\n      return v.at( /** @type {?} */((<number>name))) || null;\n    }\n\n    return null;\n  }, control);\n}\n/**\n * @param {?} r\n * @return {?}\n */\nfunction toObservable(r: any): Observable<any> {\n  return isPromise(r) ? fromPromise(r) : r;\n}\n/**\n * @param {?} validator\n * @return {?}\n */\nfunction coerceToValidator(validator: ValidatorFn | ValidatorFn[]): ValidatorFn {\n  return Array.isArray(validator) ? composeValidators(validator) : validator;\n}\n/**\n * @param {?} asyncValidator\n * @return {?}\n */\nfunction coerceToAsyncValidator(asyncValidator: AsyncValidatorFn | AsyncValidatorFn[]):\n    AsyncValidatorFn {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;\n}\n/**\n * \\@whatItDoes This is the base class for {\\@link FormControl}, {\\@link FormGroup}, and\n * {\\@link FormArray}.\n * \n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n * \n * \\@stable\n * @abstract\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  _value: any;\n  /** @internal */\n  _onCollectionChange = () => {};\nprivate _valueChanges: EventEmitter<any>;\nprivate _statusChanges: EventEmitter<any>;\nprivate _status: string;\nprivate _errors: {[key: string]: any};\nprivate _pristine: boolean = true;\nprivate _touched: boolean = false;\nprivate _parent: FormGroup|FormArray;\nprivate _asyncValidationSubscription: any;\n/**\n * @param {?} validator\n * @param {?} asyncValidator\n */\nconstructor(public validator: ValidatorFn,\npublic asyncValidator: AsyncValidatorFn) {}\n/**\n * The value of the control.\n * @return {?}\n */\nget value(): any { return this._value; }\n/**\n * The parent control.\n * @return {?}\n */\nget parent(): FormGroup|FormArray { return this._parent; }\n/**\n * The validation status of the control. There are four possible\n * validation statuses:\n * \n * * **VALID**:  control has passed all validation checks\n * * **INVALID**: control has failed at least one validation check\n * * **PENDING**: control is in the midst of conducting a validation check\n * * **DISABLED**: control is exempt from validation checks\n * \n * These statuses are mutually exclusive, so a control cannot be\n * both valid AND invalid or invalid AND disabled.\n * @return {?}\n */\nget status(): string { return this._status; }\n/**\n * A control is `valid` when its `status === VALID`.\n * \n * In order to have this status, the control must have passed all its\n * validation checks.\n * @return {?}\n */\nget valid(): boolean { return this._status === VALID; }\n/**\n * A control is `invalid` when its `status === INVALID`.\n * \n * In order to have this status, the control must have failed\n * at least one of its validation checks.\n * @return {?}\n */\nget invalid(): boolean { return this._status === INVALID; }\n/**\n * A control is `pending` when its `status === PENDING`.\n * \n * In order to have this status, the control must be in the\n * middle of conducting a validation check.\n * @return {?}\n */\nget pending(): boolean { return this._status == PENDING; }\n/**\n * A control is `disabled` when its `status === DISABLED`.\n * \n * Disabled controls are exempt from validation checks and\n * are not included in the aggregate value of their ancestor\n * controls.\n * @return {?}\n */\nget disabled(): boolean { return this._status === DISABLED; }\n/**\n * A control is `enabled` as long as its `status !== DISABLED`.\n * \n * In other words, it has a status of `VALID`, `INVALID`, or\n * `PENDING`.\n * @return {?}\n */\nget enabled(): boolean { return this._status !== DISABLED; }\n/**\n * Returns any errors generated by failing validation. If there\n * are no errors, it will return null.\n * @return {?}\n */\nget errors(): {[key: string]: any} { return this._errors; }\n/**\n * A control is `pristine` if the user has not yet changed\n * the value in the UI.\n * \n * Note that programmatic changes to a control's value will\n * *not* mark it dirty.\n * @return {?}\n */\nget pristine(): boolean { return this._pristine; }\n/**\n * A control is `dirty` if the user has changed the value\n * in the UI.\n * \n * Note that programmatic changes to a control's value will\n * *not* mark it dirty.\n * @return {?}\n */\nget dirty(): boolean { return !this.pristine; }\n/**\n * A control is marked `touched` once the user has triggered\n * a `blur` event on it.\n * @return {?}\n */\nget touched(): boolean { return this._touched; }\n/**\n * A control is `untouched` if the user has not yet triggered\n * a `blur` event on it.\n * @return {?}\n */\nget untouched(): boolean { return !this._touched; }\n/**\n * Emits an event every time the value of the control changes, in\n * the UI or programmatically.\n * @return {?}\n */\nget valueChanges(): Observable<any> { return this._valueChanges; }\n/**\n * Emits an event every time the validation status of the control\n * is re-calculated.\n * @return {?}\n */\nget statusChanges(): Observable<any> { return this._statusChanges; }\n/**\n * Sets the synchronous validators that are active on this control.  Calling\n * this will overwrite any existing sync validators.\n * @param {?} newValidator\n * @return {?}\n */\nsetValidators(newValidator: ValidatorFn|ValidatorFn[]): void {\n    this.validator = coerceToValidator(newValidator);\n  }\n/**\n * Sets the async validators that are active on this control. Calling this\n * will overwrite any existing async validators.\n * @param {?} newValidator\n * @return {?}\n */\nsetAsyncValidators(newValidator: AsyncValidatorFn|AsyncValidatorFn[]): void {\n    this.asyncValidator = coerceToAsyncValidator(newValidator);\n  }\n/**\n * Empties out the sync validator list.\n * @return {?}\n */\nclearValidators(): void { this.validator = null; }\n/**\n * Empties out the async validator list.\n * @return {?}\n */\nclearAsyncValidators(): void { this.asyncValidator = null; }\n/**\n * Marks the control as `touched`.\n * \n * This will also mark all direct ancestors as `touched` to maintain\n * the model.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsTouched({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._touched = true;\n\n    if (this._parent && !onlySelf) {\n      this._parent.markAsTouched({onlySelf});\n    }\n  }\n/**\n * Marks the control as `untouched`.\n * \n * If the control has any children, it will also mark all children as `untouched`\n * to maintain the model, and re-calculate the `touched` status of all parent\n * controls.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsUntouched({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._touched = false;\n\n    this._forEachChild(\n        (control: AbstractControl) => { control.markAsUntouched({onlySelf: true}); });\n\n    if (this._parent && !onlySelf) {\n      this._parent._updateTouched({onlySelf});\n    }\n  }\n/**\n * Marks the control as `dirty`.\n * \n * This will also mark all direct ancestors as `dirty` to maintain\n * the model.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsDirty({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._pristine = false;\n\n    if (this._parent && !onlySelf) {\n      this._parent.markAsDirty({onlySelf});\n    }\n  }\n/**\n * Marks the control as `pristine`.\n * \n * If the control has any children, it will also mark all children as `pristine`\n * to maintain the model, and re-calculate the `pristine` status of all parent\n * controls.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsPristine({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._pristine = true;\n\n    this._forEachChild((control: AbstractControl) => { control.markAsPristine({onlySelf: true}); });\n\n    if (this._parent && !onlySelf) {\n      this._parent._updatePristine({onlySelf});\n    }\n  }\n/**\n * Marks the control as `pending`.\n * @param {?=} __0\n * @return {?}\n */\nmarkAsPending({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._status = PENDING;\n\n    if (this._parent && !onlySelf) {\n      this._parent.markAsPending({onlySelf});\n    }\n  }\n/**\n * Disables the control. This means the control will be exempt from validation checks and\n * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n * \n * If the control has children, all children will be disabled to maintain the model.\n * @param {?=} __0\n * @return {?}\n */\ndisable({onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._status = DISABLED;\n    this._errors = null;\n    this._forEachChild((control: AbstractControl) => { control.disable({onlySelf: true}); });\n    this._updateValue();\n\n    if (emitEvent !== false) {\n      this._valueChanges.emit(this._value);\n      this._statusChanges.emit(this._status);\n    }\n\n    this._updateAncestors(onlySelf);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n/**\n * Enables the control. This means the control will be included in validation checks and\n * the aggregate value of its parent. Its status is re-calculated based on its value and\n * its validators.\n * \n * If the control has children, all children will be enabled.\n * @param {?=} __0\n * @return {?}\n */\nenable({onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._status = VALID;\n    this._forEachChild((control: AbstractControl) => { control.enable({onlySelf: true}); });\n    this.updateValueAndValidity({onlySelf: true, emitEvent});\n\n    this._updateAncestors(onlySelf);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n/**\n * @param {?} onlySelf\n * @return {?}\n */\nprivate _updateAncestors(onlySelf: boolean) {\n    if (this._parent && !onlySelf) {\n      this._parent.updateValueAndValidity();\n      this._parent._updatePristine();\n      this._parent._updateTouched();\n    }\n  }\n/**\n * @param {?} parent\n * @return {?}\n */\nsetParent(parent: FormGroup|FormArray): void { this._parent = parent; }\n/**\n * Sets the value of the control. Abstract method (implemented in sub-classes).\n * @abstract\n * @param {?} value\n * @param {?=} options\n * @return {?}\n */\nsetValue(value: any, options?: Object) {}\n/**\n * Patches the value of the control. Abstract method (implemented in sub-classes).\n * @abstract\n * @param {?} value\n * @param {?=} options\n * @return {?}\n */\npatchValue(value: any, options?: Object) {}\n/**\n * Resets the control. Abstract method (implemented in sub-classes).\n * @abstract\n * @param {?=} value\n * @param {?=} options\n * @return {?}\n */\nreset(value?: any, options?: Object) {}\n/**\n * Re-calculates the value and validation status of the control.\n * \n * By default, it will also update the value and validity of its ancestors.\n * @param {?=} __0\n * @return {?}\n */\nupdateValueAndValidity({onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._errors = this._runValidator();\n      this._status = this._calculateStatus();\n\n      if (this._status === VALID || this._status === PENDING) {\n        this._runAsyncValidator(emitEvent);\n      }\n    }\n\n    if (emitEvent !== false) {\n      this._valueChanges.emit(this._value);\n      this._statusChanges.emit(this._status);\n    }\n\n    if (this._parent && !onlySelf) {\n      this._parent.updateValueAndValidity({onlySelf, emitEvent});\n    }\n  }\n/**\n * \\@internal\n * @param {?=} __0\n * @return {?}\n */\n_updateTreeValidity({emitEvent}: {emitEvent?: boolean} = {emitEvent: true}) {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity({emitEvent}));\n    this.updateValueAndValidity({onlySelf: true, emitEvent});\n  }\n/**\n * @return {?}\n */\nprivate _setInitialStatus() { this._status = this._allControlsDisabled() ? DISABLED : VALID; }\n/**\n * @return {?}\n */\nprivate _runValidator(): {[key: string]: any} {\n    return this.validator ? this.validator(this) : null;\n  }\n/**\n * @param {?} emitEvent\n * @return {?}\n */\nprivate _runAsyncValidator(emitEvent: boolean): void {\n    if (this.asyncValidator) {\n      this._status = PENDING;\n      this._cancelExistingSubscription();\n      const /** @type {?} */ obs = toObservable(this.asyncValidator(this));\n      if (!(isObservable(obs))) {\n        throw new Error(\n            `expected the following validator to return Promise or Observable: ${this.asyncValidator}. If you are using FormBuilder; did you forget to brace your validators in an array?`);\n      }\n      this._asyncValidationSubscription =\n          obs.subscribe({next: (res: {[key: string]: any}) => this.setErrors(res, {emitEvent})});\n    }\n  }\n/**\n * @return {?}\n */\nprivate _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n    }\n  }\n/**\n * Sets errors on a form control.\n * \n * This is used when validations are run manually by the user, rather than automatically.\n * \n * Calling `setErrors` will also update the validity of the parent control.\n * \n * ### Example\n * \n * ```\n * const login = new FormControl(\"someLogin\");\n * login.setErrors({\n *   \"notUnique\": true\n * });\n * \n * expect(login.valid).toEqual(false);\n * expect(login.errors).toEqual({\"notUnique\": true});\n * \n * login.setValue(\"someOtherLogin\");\n * \n * expect(login.valid).toEqual(true);\n * ```\n * @param {?} errors\n * @param {?=} __1\n * @return {?}\n */\nsetErrors(errors: {[key: string]: any}, {emitEvent}: {emitEvent?: boolean} = {}): void {\n    this._errors = errors;\n    this._updateControlsErrors(emitEvent !== false);\n  }\n/**\n * Retrieves a child control given the control's name or path.\n * \n * Paths can be passed in as an array or a string delimited by a dot.\n * \n * To get a control nested within a `person` sub-group:\n * \n * * `this.form.get('person.name');`\n * \n * -OR-\n * \n * * `this.form.get(['person', 'name']);`\n * @param {?} path\n * @return {?}\n */\nget(path: Array<string|number>|string): AbstractControl { return _find(this, path, '.'); }\n/**\n * Returns true if the control with the given path has the error specified. Otherwise\n * returns null or undefined.\n * \n * If no path is given, it checks for the error on the present control.\n * @param {?} errorCode\n * @param {?=} path\n * @return {?}\n */\ngetError(errorCode: string, path: string[] = null): any {\n    const /** @type {?} */ control = path ? this.get(path) : this;\n    return control && control._errors ? control._errors[errorCode] : null;\n  }\n/**\n * Returns true if the control with the given path has the error specified. Otherwise\n * returns false.\n * \n * If no path is given, it checks for the error on the present control.\n * @param {?} errorCode\n * @param {?=} path\n * @return {?}\n */\nhasError(errorCode: string, path: string[] = null): boolean {\n    return !!this.getError(errorCode, path);\n  }\n/**\n * Retrieves the top-level ancestor of this control.\n * @return {?}\n */\nget root(): AbstractControl {\n    let /** @type {?} */ x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n/**\n * \\@internal\n * @param {?} emitEvent\n * @return {?}\n */\n_updateControlsErrors(emitEvent: boolean): void {\n    this._status = this._calculateStatus();\n\n    if (emitEvent) {\n      this._statusChanges.emit(this._status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_initObservables() {\n    this._valueChanges = new EventEmitter();\n    this._statusChanges = new EventEmitter();\n  }\n/**\n * @return {?}\n */\nprivate _calculateStatus(): string {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this._errors) return INVALID;\n    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n/**\n * \\@internal\n * @abstract\n * @return {?}\n */\n_updateValue() {}\n/**\n * \\@internal\n * @abstract\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: Function) {}\n/**\n * \\@internal\n * @abstract\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function) {}\n/**\n * \\@internal\n * @abstract\n * @return {?}\n */\n_allControlsDisabled() {}\n/**\n * \\@internal\n * @param {?} status\n * @return {?}\n */\n_anyControlsHaveStatus(status: string): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n/**\n * \\@internal\n * @param {?=} __0\n * @return {?}\n */\n_updatePristine({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._pristine = !this._anyControlsDirty();\n\n    if (this._parent && !onlySelf) {\n      this._parent._updatePristine({onlySelf});\n    }\n  }\n/**\n * \\@internal\n * @param {?=} __0\n * @return {?}\n */\n_updateTouched({onlySelf}: {onlySelf?: boolean} = {}): void {\n    this._touched = this._anyControlsTouched();\n\n    if (this._parent && !onlySelf) {\n      this._parent._updateTouched({onlySelf});\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Function[] = [];\n/**\n * \\@internal\n * @param {?} formState\n * @return {?}\n */\n_isBoxedValue(formState: any): boolean {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n  }\n/**\n * \\@internal\n * @param {?} fn\n * @return {?}\n */\n_registerOnCollectionChange(fn: () => void): void { this._onCollectionChange = fn; }\n}\n\nfunction AbstractControl_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nAbstractControl.prototype._value;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractControl.prototype._onCollectionChange;\n/** @type {?} */\nAbstractControl.prototype._valueChanges;\n/** @type {?} */\nAbstractControl.prototype._statusChanges;\n/** @type {?} */\nAbstractControl.prototype._status;\n/** @type {?} */\nAbstractControl.prototype._errors;\n/** @type {?} */\nAbstractControl.prototype._pristine;\n/** @type {?} */\nAbstractControl.prototype._touched;\n/** @type {?} */\nAbstractControl.prototype._parent;\n/** @type {?} */\nAbstractControl.prototype._asyncValidationSubscription;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractControl.prototype._onDisabledChange;\n/** @type {?} */\nAbstractControl.prototype.validator;\n/** @type {?} */\nAbstractControl.prototype.asyncValidator;\n}\n\n/**\n * \\@whatItDoes Tracks the value and validation status of an individual form control.\n * \n * It is one of the three fundamental building blocks of Angular forms, along with\n * {\\@link FormGroup} and {\\@link FormArray}.\n * \n * \\@howToUse \n * \n * When instantiating a {\\@link FormControl}, you can pass in an initial value as the\n * first argument. Example:\n * \n * ```ts\n * const ctrl = new FormControl('some value');\n * console.log(ctrl.value);     // 'some value'\n * ```\n * \n * You can also initialize the control with a form state object on instantiation,\n * which includes both the value and whether or not the control is disabled.\n * You can't use the value key without the disabled key; both are required\n * to use this way of initialization.\n * \n * ```ts\n * const ctrl = new FormControl({value: 'n/a', disabled: true});\n * console.log(ctrl.value);     // 'n/a'\n * console.log(ctrl.status);   // 'DISABLED'\n * ```\n * \n * To include a sync validator (or an array of sync validators) with the control,\n * pass it in as the second argument. Async validators are also supported, but\n * have to be passed in separately as the third arg.\n * \n * ```ts\n * const ctrl = new FormControl('', Validators.required);\n * console.log(ctrl.value);     // ''\n * console.log(ctrl.status);   // 'INVALID'\n * ```\n * \n * See its superclass, {\\@link AbstractControl}, for more properties and methods.\n * \n * * **npm package**: `\\@angular/forms`\n * \n * \\@stable\n */\nexport class FormControl extends AbstractControl {\n  /** @internal */\n  _onChange: Function[] = [];\n/**\n * @param {?=} formState\n * @param {?=} validator\n * @param {?=} asyncValidator\n */\nconstructor(\n      formState: any = null, validator: ValidatorFn|ValidatorFn[] = null,\n      asyncValidator: AsyncValidatorFn|AsyncValidatorFn[] = null) {\n    super(coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));\n    this._applyFormState(formState);\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n    this._initObservables();\n  }\n/**\n * Set the value of the form control to `value`.\n * \n * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`\n * and not its parent component. This defaults to false.\n * \n * If `emitEvent` is `true`, this\n * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults\n * to true (as it falls through to `updateValueAndValidity`).\n * \n * If `emitModelToViewChange` is `true`, the view will be notified about the new value\n * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not\n * specified.\n * \n * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the\n * model.  This is the default behavior if `emitViewToModelChange` is not specified.\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\nsetValue(value: any, {onlySelf, emitEvent, emitModelToViewChange, emitViewToModelChange}: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this._value = value;\n    if (this._onChange.length && emitModelToViewChange !== false) {\n      this._onChange.forEach((changeFn) => changeFn(this._value, emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n * Patches the value of a control.\n * \n * This function is functionally the same as {\\@link FormControl.setValue} at this level.\n * It exists for symmetry with {\\@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,\n * where it does behave differently.\n * @param {?} value\n * @param {?=} options\n * @return {?}\n */\npatchValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this.setValue(value, options);\n  }\n/**\n * Resets the form control. This means by default:\n * \n * * it is marked as `pristine`\n * * it is marked as `untouched`\n * * value is set to null\n * \n * You can also reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n * \n * Ex:\n * \n * ```ts\n * this.control.reset('Nancy');\n * \n * console.log(this.control.value);  // 'Nancy'\n * ```\n * \n * OR\n * \n * ```\n * this.control.reset({value: 'Nancy', disabled: true});\n * \n * console.log(this.control.value);  // 'Nancy'\n * console.log(this.control.status);  // 'DISABLED'\n * ```\n * @param {?=} formState\n * @param {?=} __1\n * @return {?}\n */\nreset(formState: any = null, {onlySelf, emitEvent}: {onlySelf?: boolean,\n                                                       emitEvent?: boolean} = {}): void {\n    this._applyFormState(formState);\n    this.markAsPristine({onlySelf});\n    this.markAsUntouched({onlySelf});\n    this.setValue(this._value, {onlySelf, emitEvent});\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_updateValue() {}\n/**\n * \\@internal\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function): boolean { return false; }\n/**\n * \\@internal\n * @return {?}\n */\n_allControlsDisabled(): boolean { return this.disabled; }\n/**\n * Register a listener for change events.\n * @param {?} fn\n * @return {?}\n */\nregisterOnChange(fn: Function): void { this._onChange.push(fn); }\n/**\n * \\@internal\n * @return {?}\n */\n_clearChangeFns(): void {\n    this._onChange = [];\n    this._onDisabledChange = [];\n    this._onCollectionChange = () => {};\n  }\n/**\n * Register a listener for disabled events.\n * @param {?} fn\n * @return {?}\n */\nregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n/**\n * \\@internal\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: Function): void {}\n/**\n * @param {?} formState\n * @return {?}\n */\nprivate _applyFormState(formState: any) {\n    if (this._isBoxedValue(formState)) {\n      this._value = formState.value;\n      formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                           this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      this._value = formState;\n    }\n  }\n}\n\nfunction FormControl_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nFormControl.prototype._onChange;\n}\n\n/**\n * \\@whatItDoes Tracks the value and validity state of a group of {\\@link FormControl}\n * instances.\n * \n * A `FormGroup` aggregates the values of each child {\\@link FormControl} into one object,\n * with each control name as the key.  It calculates its status by reducing the statuses\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n * \n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with {\\@link FormControl} and {\\@link FormArray}.\n * \n * \\@howToUse \n * \n * When instantiating a {\\@link FormGroup}, pass in a collection of child controls as the first\n * argument. The key for each child will be the name under which it is registered.\n * \n * ### Example\n * \n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n * \n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n * \n * You can also include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n * \n * ### Example\n * \n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n * \n * \n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n * \n * * **npm package**: `\\@angular/forms`\n * \n * \\@stable\n */\nexport class FormGroup extends AbstractControl {\n/**\n * @param {?} controls\n * @param {?=} validator\n * @param {?=} asyncValidator\n */\nconstructor(\npublic controls: {[key: string]: AbstractControl}, validator: ValidatorFn = null,\n      asyncValidator: AsyncValidatorFn = null) {\n    super(validator, asyncValidator);\n    this._initObservables();\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n/**\n * Registers a control with the group's list of controls.\n * \n * This method does not update value or validity of the control, so for\n * most cases you'll want to use {\\@link FormGroup.addControl} instead.\n * @param {?} name\n * @param {?} control\n * @return {?}\n */\nregisterControl(name: string, control: AbstractControl): AbstractControl {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n/**\n * Add a control to this group.\n * @param {?} name\n * @param {?} control\n * @return {?}\n */\naddControl(name: string, control: AbstractControl): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Remove a control from this group.\n * @param {?} name\n * @return {?}\n */\nremoveControl(name: string): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Replace an existing control.\n * @param {?} name\n * @param {?} control\n * @return {?}\n */\nsetControl(name: string, control: AbstractControl): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Check whether there is an enabled control with the given name in the group.\n * \n * It will return false for disabled controls. If you'd like to check for\n * existence in the group only, use {\\@link AbstractControl.get} instead.\n * @param {?} controlName\n * @return {?}\n */\ncontains(controlName: string): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n/**\n *  Sets the value of the {\\@link FormGroup}. It accepts an object that matches\n *  the structure of the group, with control names as keys.\n * \n * This method performs strict checks, so it will throw an error if you try\n * to set the value of a control that doesn't exist or if you exclude the\n * value of a control.\n * \n *  ### Example\n * \n *  ```\n *  const form = new FormGroup({\n *     first: new FormControl(),\n *     last: new FormControl()\n *  });\n *  console.log(form.value);   // {first: null, last: null}\n * \n *  form.setValue({first: 'Nancy', last: 'Drew'});\n *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n * \n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\nsetValue(\n      value: {[key: string]: any},\n      {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n *  Patches the value of the {\\@link FormGroup}. It accepts an object with control\n *  names as keys, and will do its best to match the values to the correct controls\n *  in the group.\n * \n *  It accepts both super-sets and sub-sets of the group without throwing an error.\n * \n *  ### Example\n * \n *  ```\n *  const form = new FormGroup({\n *     first: new FormControl(),\n *     last: new FormControl()\n *  });\n *  console.log(form.value);   // {first: null, last: null}\n * \n *  form.patchValue({first: 'Nancy'});\n *  console.log(form.value);   // {first: 'Nancy', last: null}\n * \n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\npatchValue(\n      value: {[key: string]: any},\n      {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent});\n      }\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n * Resets the {\\@link FormGroup}. This means by default:\n * \n * * The group and all descendants are marked `pristine`\n * * The group and all descendants are marked `untouched`\n * * The value of all descendants will be null or null maps\n * \n * You can also reset to a specific form state by passing in a map of states\n * that matches the structure of your form, with control names as keys. The state\n * can be a standalone value or a form state object with both a value and a disabled\n * status.\n * \n * ### Example\n * \n * ```ts\n * this.form.reset({first: 'name', last: 'last name'});\n * \n * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n * ```\n * \n * - OR -\n * \n * ```\n * this.form.reset({\n *   first: {value: 'name', disabled: true},\n *   last: 'last'\n * });\n * \n * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n * console.log(this.form.get('first').status);  // 'DISABLED'\n * ```\n * @param {?=} value\n * @param {?=} __1\n * @return {?}\n */\nreset(value: any = {}, {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      control.reset(value[name], {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n    this._updatePristine({onlySelf});\n    this._updateTouched({onlySelf});\n  }\n/**\n * The aggregate value of the {\\@link FormGroup}, including any disabled controls.\n * \n * If you'd like to include all values regardless of disabled status, use this method.\n * Otherwise, the `value` property is the best way to get the value of the group.\n * @return {?}\n */\ngetRawValue(): any {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          acc[name] = control instanceof FormControl ? control.value : ( /** @type {?} */((<any>control))).getRawValue();\n          return acc;\n        });\n  }\n/**\n * \\@internal\n * @param {?} name\n * @return {?}\n */\n_throwIfControlMissing(name: string): void {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n/**\n * \\@internal\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: (v: any, k: string) => void): void {\n    Object.keys(this.controls).forEach(k => cb(this.controls[k], k));\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_updateValue(): void { this._value = this._reduceValue(); }\n/**\n * \\@internal\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function): boolean {\n    let /** @type {?} */ res = false;\n    this._forEachChild((control: AbstractControl, name: string) => {\n      res = res || (this.contains(name) && condition(control));\n    });\n    return res;\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_reduceValue() {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          if (control.enabled || this.disabled) {\n            acc[name] = control.value;\n          }\n          return acc;\n        });\n  }\n/**\n * \\@internal\n * @param {?} initValue\n * @param {?} fn\n * @return {?}\n */\n_reduceChildren(initValue: any, fn: Function) {\n    let /** @type {?} */ res = initValue;\n    this._forEachChild(\n        (control: AbstractControl, name: string) => { res = fn(res, control, name); });\n    return res;\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_allControlsDisabled(): boolean {\n    for (const /** @type {?} */ controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n/**\n * \\@internal\n * @param {?} value\n * @return {?}\n */\n_checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n}\n\nfunction FormGroup_tsickle_Closure_declarations() {\n/** @type {?} */\nFormGroup.prototype.controls;\n}\n\n/**\n * \\@whatItDoes Tracks the value and validity state of an array of {\\@link FormControl},\n * {\\@link FormGroup} or {\\@link FormArray} instances.\n * \n * A `FormArray` aggregates the values of each child {\\@link FormControl} into an array.\n * It calculates its status by reducing the statuses of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n * \n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with {\\@link FormControl} and {\\@link FormGroup}.\n * \n * \\@howToUse \n * \n * When instantiating a {\\@link FormArray}, pass in an array of child controls as the first\n * argument.\n * \n * ### Example\n * \n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n * \n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n * \n * You can also include array-level validators as the second arg, or array-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n * \n * ### Adding or removing controls\n * \n * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that will result in strange and unexpected behavior such\n * as broken change detection.\n * \n * * **npm package**: `\\@angular/forms`\n * \n * \\@stable\n */\nexport class FormArray extends AbstractControl {\n/**\n * @param {?} controls\n * @param {?=} validator\n * @param {?=} asyncValidator\n */\nconstructor(\npublic controls: AbstractControl[], validator: ValidatorFn = null,\n      asyncValidator: AsyncValidatorFn = null) {\n    super(validator, asyncValidator);\n    this._initObservables();\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n/**\n * Get the {\\@link AbstractControl} at the given `index` in the array.\n * @param {?} index\n * @return {?}\n */\nat(index: number): AbstractControl { return this.controls[index]; }\n/**\n * Insert a new {\\@link AbstractControl} at the end of the array.\n * @param {?} control\n * @return {?}\n */\npush(control: AbstractControl): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Insert a new {\\@link AbstractControl} at the given `index` in the array.\n * @param {?} index\n * @param {?} control\n * @return {?}\n */\ninsert(index: number, control: AbstractControl): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Remove the control at the given `index` in the array.\n * @param {?} index\n * @return {?}\n */\nremoveAt(index: number): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Replace an existing control.\n * @param {?} index\n * @param {?} control\n * @return {?}\n */\nsetControl(index: number, control: AbstractControl): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n/**\n * Length of the control array.\n * @return {?}\n */\nget length(): number { return this.controls.length; }\n/**\n *  Sets the value of the {\\@link FormArray}. It accepts an array that matches\n *  the structure of the control.\n * \n * This method performs strict checks, so it will throw an error if you try\n * to set the value of a control that doesn't exist or if you exclude the\n * value of a control.\n * \n *  ### Example\n * \n *  ```\n *  const arr = new FormArray([\n *     new FormControl(),\n *     new FormControl()\n *  ]);\n *  console.log(arr.value);   // [null, null]\n * \n *  arr.setValue(['Nancy', 'Drew']);\n *  console.log(arr.value);   // ['Nancy', 'Drew']\n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\nsetValue(value: any[], {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue: any, index: number) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n *  Patches the value of the {\\@link FormArray}. It accepts an array that matches the\n *  structure of the control, and will do its best to match the values to the correct\n *  controls in the group.\n * \n *  It accepts both super-sets and sub-sets of the array without throwing an error.\n * \n *  ### Example\n * \n *  ```\n *  const arr = new FormArray([\n *     new FormControl(),\n *     new FormControl()\n *  ]);\n *  console.log(arr.value);   // [null, null]\n * \n *  arr.patchValue(['Nancy']);\n *  console.log(arr.value);   // ['Nancy', null]\n *  ```\n * @param {?} value\n * @param {?=} __1\n * @return {?}\n */\npatchValue(value: any[], {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    value.forEach((newValue: any, index: number) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent});\n      }\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n  }\n/**\n * Resets the {\\@link FormArray}. This means by default:\n * \n * * The array and all descendants are marked `pristine`\n * * The array and all descendants are marked `untouched`\n * * The value of all descendants will be null or null maps\n * \n * You can also reset to a specific form state by passing in an array of states\n * that matches the structure of the control. The state can be a standalone value\n * or a form state object with both a value and a disabled status.\n * \n * ### Example\n * \n * ```ts\n * this.arr.reset(['name', 'last name']);\n * \n * console.log(this.arr.value);  // ['name', 'last name']\n * ```\n * \n * - OR -\n * \n * ```\n * this.arr.reset([\n *   {value: 'name', disabled: true},\n *   'last'\n * ]);\n * \n * console.log(this.arr.value);  // ['name', 'last name']\n * console.log(this.arr.get(0).status);  // 'DISABLED'\n * ```\n * @param {?=} value\n * @param {?=} __1\n * @return {?}\n */\nreset(value: any = [], {onlySelf, emitEvent}: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent});\n    });\n    this.updateValueAndValidity({onlySelf, emitEvent});\n    this._updatePristine({onlySelf});\n    this._updateTouched({onlySelf});\n  }\n/**\n * The aggregate value of the array, including any disabled controls.\n * \n * If you'd like to include all values regardless of disabled status, use this method.\n * Otherwise, the `value` property is the best way to get the value of the array.\n * @return {?}\n */\ngetRawValue(): any[] {\n    return this.controls.map((control: AbstractControl) => {\n      return control instanceof FormControl ? control.value : ( /** @type {?} */((<any>control))).getRawValue();\n    });\n  }\n/**\n * \\@internal\n * @param {?} index\n * @return {?}\n */\n_throwIfControlMissing(index: number): void {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n/**\n * \\@internal\n * @param {?} cb\n * @return {?}\n */\n_forEachChild(cb: Function): void {\n    this.controls.forEach((control: AbstractControl, index: number) => { cb(control, index); });\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_updateValue(): void {\n    this._value = this.controls.filter((control) => control.enabled || this.disabled)\n                      .map((control) => control.value);\n  }\n/**\n * \\@internal\n * @param {?} condition\n * @return {?}\n */\n_anyControls(condition: Function): boolean {\n    return this.controls.some((control: AbstractControl) => control.enabled && condition(control));\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => this._registerControl(control));\n  }\n/**\n * \\@internal\n * @param {?} value\n * @return {?}\n */\n_checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, i: number) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n/**\n * \\@internal\n * @return {?}\n */\n_allControlsDisabled(): boolean {\n    for (const /** @type {?} */ control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n/**\n * @param {?} control\n * @return {?}\n */\nprivate _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n}\n\nfunction FormArray_tsickle_Closure_declarations() {\n/** @type {?} */\nFormArray.prototype.controls;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}